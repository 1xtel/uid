# k-ordered unique identity

The library provide interface to generate k-ordered unique id in lock-free and decentralized manner for Erlang application. The concept is similar to snowflake identity schema.


## Inspiration

The goals was to develop an identity schema suitable for rough, lexicographical events ordering. The library aims following objectives:

* use _64-bit_ for storage "friendly" identity schema. It allows to reduce indexes footprints and optimize lookup latency.    

* generated values are suitable for partial event ordering in distributed systems and help on detection of causality violation.

* values are roughly sortable by time.


## Background

The library developed a dual schema: 64-bit unique identity to be used within Erlang virtual machine and 96-bit unique identity for distributed clusters. Note that 96-bit is a optimized version of original 128-bits schema. Client applications benefits from short 64-bit identity using it locally and dynamically switches schema while communicating with remote peers. 

The k-ordered value consists of time-stamp with millisecond resolution (50-bit) that is used to roughly sort events. The time-stamp ensures distinct sorting within virtual machine where system clock is controlled by operation system. A locally monotonic padding (14-bits) prevents the collisions (Note: 14-bits allows to have about 16K allocations per millisecond). 

The time-stamp based sorting fails on distributed systems unless it implements precises time synchronization protocol. Therefore, it was decided to uses location aspect (node identifier) as first component of k-order value. It allows to keep ordering consistent even if clocks on other node is skewed. The distributed environment requires a partial ordering (aka vector clock) anyway.  


## Format

## 64-bit, local, version 2

```
        20bit          20bit        10bit         14bit
   |--------------|--------------|----------|-----------------|
          A              B             C           Seq
   
   A, B, C - time stamp in milliseconds
   Seq     - sequence value generated by erlang:unique_integer([monotonic])
```


Version 2 is improves allocation performance of k-order values. It uses Erlang OTP/18 or later feature `erlang:unique_integer(...)` to generate locally monotonic value. The library allocates about 13M k-order values per second on reference hardware.

* 32-bit (optionally 64-bit) represent unique node identifier allocated randomly to each node (derived as hash from long node name). Node id has higher priority during sorting then time-stamp, which allows to build reliable sorting without time synchronization.

* 50-bit time-stamp with millisecond resolution.

* 14-bit monotonic sequence identifier obtained from `erlang:unique_integer(...)`.


## 64-bit, local, version 1

```
        20bit          20bit        10bit     4bit    10bit
   |--------------|--------------|----------|------|----------|
          A              B             C       Id      Seq
   
   A, B, C - time stamp in milliseconds
   Id      - sequence identifier
   Seq     - sequence value 
```

Version 1 is developed for Erlang OTP/17 or earlier. It maintain a pool of auto-increment sequences to generate the unique locally monotonic padding. The library allocates about 1M k-order values per second on reference hardware.

* 32-bit (optionally 64-bit) represent unique node identifier allocated randomly to each node (derived as hash from long node name). Node id has higher priority during sorting then time-stamp, which allows to build reliable sorting without time synchronization.

* 50-bit time-stamp with millisecond resolution.

* 4-bit auto-increment sequence identifier. Each node maintain up to 16 sequences, the client process is sticked randomly to one of sequence. This allows to balance allocation workload to multiple parallel processes. This approach has a trade off. It is possible to order events generated by same process if they happens with sub-millisecond frequency but logical order of parallel independent events might be skewed.

* 10-bit auto-increment sequence. The sequence is incremented only if multiple allocations happens same millisecond.



## 96-bit, global, version 2

```
            32bit                         64bit                  
   |----------------------|-----------------------------------|
             Node                          Uid    
   
   Node = erlang:phash(erlang:node(), 1 bsl 32). 

```


## 128-bit, global, version 1

```
         48bit      16bit                 64bit                  
   |--------------|-------|-----------------------------------|
     MAC / Worker    Node                  Uid    
   
   Node = erlang:phash(erlang:node(), 1 bsl 16). 

```
   