# k-ordered unique identity

The library provide interface to generate k-ordered unique id in lock-free and decentralized manner for Erlang application. The concept is similar to snowflake identity schema.


## Inspiration

The goals was to develop an identity schema suitable for rough, lexicographical events ordering. The library aims following objectives:

* use _64-bit_ for storage "friendly" identity schema. It allows to reduce indexes footprints and optimize lookup latency.    

* generated values are suitable for partial event ordering in distributed systems and help on detection of causality violation.

* values are roughly sortable by time.


## Background

The library developed a dual schema: 64-bit unique identity to be used within Erlang virtual machine and 96-bit unique identity for distributed clusters. Client applications benefits from short 64-bit identity using it locally and dynamically switches schema while communicating with remote peers. 

The k-ordered value consists of time-stamp with millisecond resolution (50-bit) that is used to roughly sort events. The time-stamp ensures distinct sorting within virtual machine where system clock is controlled by operation system. A locally monotonic padding (14-bits) prevents the collisions (Note: 14-bits allows to have about 16K allocations per millisecond). 

The time-stamp based sorting fails on distributed systems unless it implements precises time synchronization protocol. Therefore, it was decided to uses location aspect (node identifier) as component of k-order value. It allows to keep ordering consistent even if clocks on other node is skewed. The developed schema allows to control the quality of the ordering (precision) depending on the length of neighborhood interval. The location has higher priority within neighborhood of given time. 
  

## Format

## 64-bit, local, version 2

```
        20 bit         20 bit       10 bit        14 bit
   |--------------|--------------|----------|-----------------|
          A              B             C           Seq
   
   A, B, C - time stamp in milliseconds
   Seq     - sequence value generated by erlang:unique_integer([monotonic])
```


Version 2 is improves allocation performance of k-order values. It uses Erlang OTP/18 or later feature `erlang:unique_integer(...)` to generate locally monotonic value. The library allocates about 13M k-order values per second on reference hardware.

* 32-bit (optionally 64-bit) represent unique node identifier allocated randomly to each node (derived as hash from long node name). Node id has higher priority during sorting then time-stamp, which allows to build reliable sorting without time synchronization.

* 50-bit time-stamp with millisecond resolution.

* 14-bit monotonic sequence identifier obtained from `erlang:unique_integer(...)`.



## 96-bit, global, version 2

```
        20 bit        20 - X bit      32 bit       X bit      10 bit       14 bit
   |--------------|--------------|--------------|----------|----------|-----------------|
          A              B0            Node          B1         C           Seq


   Node = erlang:phash(erlang:node(), 1 bsl 32). 

```
   