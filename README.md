# k-ordered unique identity

The library provide interface to generate k-ordered unique id in lock-free and decentralized manner for Erlang application. The concept is similar to snowflake identity schema.

## background

The goals was to develop an identity schema suitable for rough (lexicographical) events ordering. There was objectives to

* build storage friendly schema that allows to reduces index footprints and optimize lookup times. The choice of 64-bit is natural for modern storages.    

* generated values are suitable for partial event ordering in distributed systems and help on detection of causality violation.

* values are roughly sortable by time

The library developed a dual schema: 64-bit unique identity to be used within Erlang virtual machine and 96-bit unique identity for distributed clusters (Note: 96-bit is a optimized version, originally developed one used 128-bits). Client applications benefits from short 64-bit identity using it locally and dynamically switches schema while communicating with remote peers. 

The 50-bit time-stamp with millisecond resolution is used to roughly sort events. The time-stamp ensures distinct sorting within virtual machine where system clock is controlled by operation system. However, it fails on distributed systems unless they implement precises time synchronization protocol. Therefore, it was decided to use location aspect (node identifier) as first component of k-order value. It allows to keep ordering consistent even if clocks on other node is skewed but it requires a partial ordering schema (aka vector clock) if you need to sort set of events in distributed environment. The latter limitation is not seen as a problem for library use-cases.    

## format

* 32-bit represent (optionally 64-bit) unique node identifier allocated randomly to each node (derived as hash from long node name). Node id has higher priority during sorting then time-stamp, which allows to build reliable sorting without time synchronization.

* 50-bit time-stamp with millisecond resolution.

* 4-bit auto-increment sequence identifier. Each node maintain up to 16 sequences, the client process is sticked randomly to one of sequence. This allows to balance allocation workload to multiple parallel processes. This approach has a trade off. It is possible to order events generated by same process if they happens with sub-millisecond frequency but logical order of parallel independent events might be skewed.

* 10-bit auto-increment sequence. The sequence is incremented only if multiple allocations happens same millisecond.

## 64-bit

```
        20bit          20bit        10bit     4bit    10bit
   |--------------|--------------|----------|------|----------|
          A              B             C       Id      Seq
   
   A, B, C - time stamp in milliseconds
   Id      - sequence identifier
   Seq     - sequence value 
```

## 96-bit

```
            32bit                         64bit                  
   |----------------------|-----------------------------------|
             Node                          Uid    
   
   Node = erlang:phash(erlang:node(), 1 bsl 32). 

```


## 128-bit

```
         48bit      16bit                 64bit                  
   |--------------|-------|-----------------------------------|
     MAC / Worker    Node                  Uid    
   
   Node = erlang:phash(erlang:node(), 1 bsl 16). 

```
   